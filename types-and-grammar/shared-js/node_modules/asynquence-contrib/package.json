{
  "name": "asynquence-contrib",
  "version": "0.9.0-a",
  "description": "contrib plugins for asynquence",
  "main": "./contrib.js",
  "scripts": {
    "test": "./node-tests.js",
    "bundle": "./bundle.js"
  },
  "peerDependencies": {
    "asynquence": "*"
  },
  "devDependencies": {
    "uglify-js": "~2.4.8",
    "native-promise-only": "latest",
    "minimist": "~0.2.0",
    "freshy": "~0.0.2"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/getify/asynquence.git"
  },
  "keywords": [
    "async",
    "flow-control",
    "sequences",
    "promise",
    "iterator",
    "generator"
  ],
  "bugs": {
    "url": "https://github.com/getify/asynquence/issues",
    "email": "getify@gmail.com"
  },
  "homepage": "https://github.com/getify/asynquence/blob/master/contrib",
  "author": {
    "name": "Kyle Simpson",
    "email": "getify@gmail.com"
  },
  "license": "MIT",
  "readme": "# asynquence Contrib\n\nOptional *asynquence* plugin helpers. The full bundle of plugins (`contrib.js`) is **~3.1k** minzipped.\n\n## Function-wrapping Adapter\n\nTo integrate *asynquence* into standard callback-oriented code bases, sometimes it's preferable to create wrappers around commonly used callback-oriented functions, to be used in place of the original functions. The wrapper automatically constructs an *asynquence* instance when called, and wires up the underlying call to the original callback-oriented function so that it maps its output behavior to the *asynquence* instance.\n\nFor example, in node.js, we can call `ASQ.wrap(..)` to wrap `fs.readFile(..)`, suppressing the callback in its signature and turning it into an *asynquence*-returning function:\n\n```js\nvar readfile = ASQ.wrap(fs.readFile);\n\nreadfile(\"something.txt\",{ encoding: \"utf8\" })\n.val(function(contents){\n\t// file contents\n})\n.or(function(err){\n\t// oops, `err` in reading file!\n});\n```\n\n**Note:** `ASQ.wrap(..)` creates a function which will automatically be async in nature, even if the underlying function would normally have called its callback immediately/synchronously. **DO NOT RELY** on ordered side-effects of such wrapped functions.\n\nMost of node.js's standard functions expect an \"error-first\" style callback, and they also expect it to be at the end of the arguments list (aka \"parameters first\"). The default settings for `ASQ.wrap(..)` assume that sort of function signature.\n\nHowever, you may need to use *asynquence* with other sorts of function signatures.\n\nFor example, some functions are the opposite in parameter order (aka \"parameters last\"), where the callback must be the first argument and any other parameters are passed after it. You can pass an options-object as the second parameter to `ASQ.wrap(..)` to signal alternative function signature behavior:\n\n```js\nfunction doSomething(cb,p1,p2) {\n\t// do something with `p1` and `p2`, then later\n\t// call `cb` as an error-first cb\n}\n\nvar better = ASQ.wrap(doSomething,{ params_last: true });\n\nbetter(\"val 1\",\"val 2\")\n.val(function(result){\n\t// result\n})\n.or(function(err){\n\t// oops, `err` occurred!\n});\n```\n\nYou also may want to specify a specific `this` binding to use with the underlying function/method call. You can do such with the normal JS `.bind(..)` utility, like `ASQ.wrap( fn.bind(obj) )`, but that gives you permanent *hard-binding* that can't be overriden, which may or may not be suitable.\n\nIf you want the more flexible \"soft binding\" (an alternate default `this` binding -- instead of `window` / `global` -- that can still be overriden), you can specify a `this` in the options object, like so:\n\n```js\nfunction doSomething(cb) {\n\tcb(this.id);\n}\n\nvar o1 = { id: 42 };\nvar o2 = { id: \"foobar\" };\n\nvar better = ASQ.wrap(doSomething,{ this: o1 });\n\n// use `o1` as default soft-bound `this`\nbetter()\n.val(function(id){\n\tid; // 42\n});\n\n// `this` is still overridable\nbetter.call(o2)\n.val(function(id){\n\tid; // \"foobar\"\n});\n```\n\nThe complete list of options you can pass:\n\n* `this`: (default: `{ }`) specifies a *soft-binding* (aka, alternate default) for `this` for the underlying function call being wrapped\n* `params_first`: (default: `true`) signals \"parameters first\" style signature\n* `params_last`: (default: `false`) signals \"parameters last\" style signature\n* `errfcb`: (default: `true`) signals \"error-first\" style callback expected\n* `splitcb`: (default: `false`) signals split success and error callbacks expected\n* `simplecb`: (default: `false`) signals simple (success-only) callback expected, which assumes an error is either passed opaquely (inaccessible to *asynquence* handling) to the callback in some way (which you must handle), or an error is `throw`n to be `try..catch` caught (which *asynquence* will handle)\n* `gen`: (default: `false`) signals that you've passed in a generator (ES6) to wrap (see below).\n\nObviously, there's several mutually exclusive combinations of these options which would be ambiguous, and are thus not allowed (will result in an immediately-thrown error upon calling `wrap(..)`), such as `errfcb: false`, `params_first: true, params_last: true`, etc. **Just avoid these.** Also, `params_first: false` is allowed, and just means `params_last: true`, but the latter is more preferable to the former.\n\n### Wrapping A Generator\n\nIf you pass `gen:true` as an option, it overrides all other options, and instead returns back a function that creates a new *asynquence* sequence with the `runner(..)` plugin (see below) wired to run the generator you passed in. Whatever arguments you pass to the wrapper will pass into the generator (accessed via `token.messages` -- again, see `runner(..)` plugin below).\n\n```js\nvar g = ASQ.wrap(function*(token){\n\tvar x = 1;\n\tfor (var i=0; i < token.messages.length; i++) {\n\t\tx = yield (x * token.messages[i]);\n\t}\n},{ gen:true });\n\ng(2,3,4)\n.val(function(msg){\n\tconsole.log(msg);\t// 24\n});\n\ng(2,3,4,5)\n.val(function(msg){\n\tconsole.log(msg);\t// 120\n});\n```\n\nThe wrapper can be called one or many times, and each time will create and return a new sequence to run the generator.\n\n## Gate-step Variations\n\n* `any(..)` is like `gate(..)`, which waits for all segments to complete, except **just one segment has to eventually succeed** to proceed on the main sequence.\n* `first(..)` is like `any(..)`, except **as soon as any segment succeeds**, the main sequence proceeds (ignoring subsequent results from other segments).\n* `race(..)` is like `first(..)`, except the main sequence proceeds **as soon as any segment completes** (either success or failure).\n* `last(..)` is like `any(..)`, except only **the latest segment to complete successfully** sends its message(s) along to the main sequence.\n* `none(..)` is the inverse of `gate(..)`: the main sequence proceeds only **if all the segments fail** (with all segment error message(s) transposed as success message(s) and vice versa).\n* `map(arr, eachFn)` allows an asynchronous mapping of an array's values to another set of values. `map(..)` constructs a gate of segments, one for each item in `arr`. Each segment invokes `eachFn(..)` for the respective item in the array.\n\n    `eachFn(item, doneTrigger, ..)` receives the respective `item` in the array and a `doneTrigger` to invoke with the new value to map back to that array position. **Note:** If multiple values are passed, that item's value will be an array (*asynquence* message wrapper) collection of the values passed.\n\n    Just like with normal gates, `eachFn(..)` also receives any sequence messages passed forward from the previous main sequence step, such as `eachFn(item, doneTrigger, msg1, msg2, ..)`. And, if any segment causes an error, the rest of the `map(..)` fails and the main sequence is flagged as error'd.\n\n    If either `arr`, `eachFn` or both are not passed to `map(..)`, it will attempt to pull them from the value-message stream it received from the previous step. Even if it does so, any subsequent messages in the stream will still pass on to the `eachFn` callback.\n\n    The final success message from a `map(..)` sequence step is the newly constructed array of mapped values.\n\n## Sequence-step Variations\n\n* `until(..)` is like `then(..)`, except it **keeps re-trying until success** or `break()` (for loop semantics) before the main sequence proceeds.\n* `try(..)` is like `then(..)`, except it proceeds as success on the main sequence **regardless of success/failure signal**. If an error is caught, it's transposed as a special-format success message: `{ catch: ... }`.\n* `waterfall(..)` is like a sequence of `then(..)`s, except the output from each step is tracked, and the aggregate of all steps' success messages thus far is the input messages to the next step (step 3 gets passed success output from both 1 and 2, etc). Thus, the final output success message(s) of `waterfall(..)` is the collection of all success messages from the waterfall's steps.\n\n    An error anywhere along the waterfall behaves like an error in any sequence, immediately jumping to error state and aborting any further success progression.\n\n### `pThen` & `pCatch` Plugins\n\n`pThen` plugin provides a `pThen(..)` sequence method which is a cousin to the core built-in `then(..)`, but it works instead with similar semantics/behavior to native ES6 Promises. In other words, if you prefer the way `then(..)` works with Promises over *asynquence*'s `then(..)`, just use `pThen(..)` instead. **Note:** `pThen(..)` doesn't have the extra sugar capabilities like `then(..)` does, such as being able to accept sequences as direct parameters, etc -- it does just what Promise `then(..)` does.\n\nAlso provided is `pCatch(..)` which has the same semantics as Promise `catch(..)`: it's literally the same as calling `pThen(null, ..)`.\n\nExample:\n\n```js\nASQ(21)\n.pThen(function(msg){\n\treturn msg * 2;\n})\n.pThen(function(msg){\n\treturn ASQ(function(done){\n\t\tsetTimeout(function(){\n\t\t\tdone(msg);\n\t\t},100);\n\t});\n})\n.pThen(function(msg){\n\treturn new Promise(function(resolve,reject){\n\t\tsetTimeout(function(){\n\t\t\treject(\"Oops:\" + msg);\n\t\t},100);\n\t});\n})\n// sequence is now in error state!\n.pThen( // or .pCatch(...\n\tnull,\n\tfunction(err) {\n\t\treturn err.toUpperCase();\n\t}\n)\n// sequence no longer in error state since\n// `pThen`/`pCatch` registered an error handler\n// which handled the sequence error.\n.pThen(\n\tfunction(msg) {\n\t\tthrow msg;\n\t}\n)\n// sequence is now in error state again!\n.pCatch( // or .pThen(null, ...\n\tfunction(err){\n\t\tconsole.log(err); // \"OOPS:42\"\n\t\treturn \"Cool\";\n\t}\n)\n// sequence no longer in error state\n.val(function(msg){\n\tconsole.log(msg); // \"Cool\"\n})\n.or(function(){}); // never called\n```\n\nYou'll notice differences from the *asynquence* core `then(..)`, and how they match Promise `then(..)` behaviors instead:\n\n1. `pThen(..)` takes a `success` and/or `failure` handler (both optional), rather than multiple `then` handlers.\n2. The `success` handler is not provided the `done` trigger.\n3. Instead, you return either an immediate value (which then passes on to the next step at the next cycle), or a sequence or promise for a value, in which case the sequence/promise is \"unwrapped\", and procession occurs only after it resolves.\n4. If you register a `failure` handler via `pThen(..)` or `pCatch(..)`, then it swallows (so you can handle) any sequence errors to that point, and essentially resets the sequence back to success state after it is passes.\n5. You can also return a value from a `failure` handler, which is the success message passed onto the next step. **Note:** Just like with Promises, a sequence/promise returned from an `failure` handler **is not \"unwrapped\"** -- it's just passed along as a normal value.\n\n### `after` & `failAfter` Plugins\n\n`after` plugin provides a sequence instance method `after(..)` which inserts a delay into a sequence at that step. The first parameter is a number of milliseconds to wait. (Optional) additional parameters provide sequence messages to pass along (overriding previous sequence messages). Otherwise, previous sequence messages pass-through the delay automatically.\n\n`after` plugin also provides a static method version `ASQ.after(..)` which is the same as `ASQ().after(..)`.\n\n\n```js\nASQ(42) // `42` gets discarded\n.after(500,\"Hello\",\"World!\")\n.val(function(msg1,msg2){\n\tconsole.log(msg1,msg2); // \"Hello\"  \"World!\"\n});\n\nASQ.after(500)\n.val(function(){\n\tconsole.log(\"Hello World!\");\n});\n```\n\n`failAfter` plugin provides both the sequence method `failAfter(..)` and the static method `ASQ.failAfter(..)`, which work exactly like the `after` plugin methods above, but result in failure rather than success.\n\nThe most common usage of the `failAfter` plugin is likely in combination with the `race(..)` plugin, to create \"timeout\" behavior:\n\n```js\n// make a 2 sec timeout for some action\nASQ()\n.race(\n\tdoSomethingAsync(..),\n\tASQ.failAfter(2000,\"Timeout!\")\n)\n.val(function(){\n\t// success!\n})\n.or(function(err){\n\terr; // \"Timeout!\"\n});\n```\n\n### `iterable-sequence` Plugin\n\n`iterable-sequence` plugin provides `ASQ.iterable()` for creating iterable sequences. See [Iterable Sequences](https://github.com/getify/asynquence/blob/master/README.md#iterable-sequences) for more information, and examples: [sync loop](https://gist.github.com/getify/8211148#file-ex1-sync-iteration-js) and [async loop](https://gist.github.com/getify/8211148#file-ex2-async-iteration-js).\n\n### `toPromise` Plugin\n\n`toPromise` plugin provides `.toPromise()` (takes zero parameters) on a *asynquence* sequence instance's API, which allows you to vend/fork a new **native `Promise`** that's chained off of your sequence. Use this plugin if you need to send an *asynquence* sequence instance into some other utility which requires a *thenable* or standard [Promises/A+ compliant](http://promisesaplus.com) promise.\n\n**Note:** The vended promise is forked off the sequence, leaving the original sequence intact, to be continuable as normal. The message(s) (both success and error) from the chain are passed along to the promise, but they are *also* retained in the sequence itself, as if the forked-off promise is ignored.\n\nExample:\n\n```js\n// make an asynquence sequence to use\nvar sq = ASQ(function(done){\n\tsetTimeout(function(){\n\t\tdone(42); // send 42 along as success message\n\t},100);\n});\n\n// fork and deal with the native promise\nsq.toPromise()\n.then(\n\t// success\n\tfunction(msg){\n\t\tconsole.log(msg); // 42\n\t},\n\t// error\n\tfunction(err){\n\t\tconsole.log(err);\n\t}\n);\n\n// also continue with the original sequence\nsq\n.val(function(msg){\n\tconsole.log(msg); // 42\n});\n```\n\nThe goal of *asynquence* is to provide everything you need for promises-based async flow control without you needing to expose and use native promises or other promise libraries/utilities. Theoretically, this plugin should only be used when *asynquence* is insufficient in some way. If you find yourself needing to regularly vend native promises from *asynquence*, perhaps *asynquence* needs to be extended to handle that use-case, so let us know!\n\n-----\n\nIf you're using *asynquence* in an older environment which doesn't have the native ES6 `Promise` built-in, but you still want to be able to use the `.toPromise()` utility, you need a `Promise` polyfill. There are plenty of choices out there, but a great one to consider is:\n\n[Native Promise Only](http://github.com/getify/native-promise-only)\n\nAs long as either the native `Promise` is there, or that global has been spec-compliant polyfilled, this `toPromise` plugin can create promises off your *asynquence* sequences.\n\n-----\n\n### `errfcb` Plugin\n\n`errfcb` plugin provides `errfcb()` on the main sequence instance API. Calling `errfcb()` returns an \"error-first\" style (aka \"node-style\") callback that can be used with any method that expects such a callback.\n\nIf the \"error-first\" callback is then invoked with the first (\"error\") parameter set, the main sequence is flagged for error as usual. Otherwise, the main sequence proceeds as success. Messages sent to the callback are passed through to the main sequence as success/error as expected.\n\nExample:\n\n```js\n// node.js: fs.readFile wrapper\nfunction readFile(filename) {\n\t// setup an empty sequence (much like an empty\n\t// promise)\n\tvar sq = ASQ();\n\n\t// call node.js `fs.readFile(..), but pass in\n\t// an error-first callback that is automatically\n\t// wired into a sequence\n\tfs.readFile( filename, sq.errfcb() );\n\n\t// now, return our sequence/promise\n\treturn sq;\n}\n\nreadFile(\"meaningoflife.txt\")\n.then(..)\n..\n```\n\n### `runner` Plugin\n\n`runner(..)` takes either an **iterable-sequence** or an ES6 generator function, which will be iterated through step-by-step. `runner(..)` will handle either *asynquence* sequences, standard promises/thenables, thunks (see [\"thunks\" here](http://zef.me/6096/callback-free-harmonious-node-js)), or immediate values as the yielded/returned values from the generator or iterable-sequence steps.\n\nThe generator/iterable-sequence will receive any value-messages from the previous sequence step (via the *control token* -- see [CSP-style Concurrency](#csp-style-concurrency) below for explanation), and the final yielded/returned value will be passed along as the success message(s) to the next main sequence step. Error(s) if any will flag the main sequence as error, with error messages passed along as expected.\n\nUsing generators:\n\n```js\nfunction thunkDouble(x) {\n\treturn function thunk(cb) {\n\t\tsetTimeout(function(){\n\t\t\t// cb is an error-first style callback\n\t\t\tcb(null,x * 2);\n\t\t},500);\n\t};\n}\n\nfunction promiseDouble(x) {\n\t// using ES6 `Promise`s\n\treturn new Promise(function(resolve,reject){\n\t\tsetTimeout(function(){\n\t\t\tresolve(x * 2);\n\t\t},500);\n\t});\n}\n\nfunction seqDouble(x) {\n\treturn ASQ(function(done){\n\t\tsetTimeout(function(){\n\t\t\tdone(x * 2);\n\t\t},500);\n\t});\n}\n\nASQ(2)\n.runner(function*(token){\n\t// extract message from control-token so\n\t// we can operate on it\n\tvar x = token.messages[0];\n\n\twhile (x < 100) {\n\t\tif (x < 10) {\n\t\t\tx = yield thunkDouble(x);\n\t\t}\n\t\telse if (x < 40) {\n\t\t\tx = yield promiseDouble(x);\n\t\t}\n\t\telse {\n\t\t\tx = yield seqDouble(x);\n\t\t}\n\t}\n})\n.val(function(num){\n\tconsole.log(num); // 128\n});\n```\n\nUsing iterable-sequences:\n\n```js\nfunction thunkDouble(x) {\n\treturn function thunk(cb) {\n\t\tsetTimeout(function(){\n\t\t\t// cb is an error-first style callback\n\t\t\tcb(null,x * 2);\n\t\t},500);\n\t};\n}\n\nfunction promiseDouble(x) {\n\t// using ES6 `Promise`s\n\treturn new Promise(function(resolve,reject){\n\t\tsetTimeout(function(){\n\t\t\tresolve(x * 2);\n\t\t},500);\n\t});\n}\n\nfunction seqDouble(x) {\n\treturn ASQ(function(done){\n\t\tsetTimeout(function(){\n\t\t\tdone(x * 2);\n\t\t},500);\n\t});\n}\n\nASQ(2)\n.runner(\n\tASQ.iterable()\n\t.then(function(token){\n\t\t// extract message from control-token so\n\t\t// we can operate on it\n\t\treturn token.messages[0];\n\t})\n\t.then(thunkDouble)\n\t.then(promiseDouble)\n\t.then(seqDouble)\n)\n.val(function(num){\n\tconsole.log(num); // 16\n});\n```\n\n#### CSP-style Concurrency\n\n`runner(..)` can accept 2 or more generators (or iterable-sequences) that you can cooperatively interleave execution of, which lets you leverage a simple form of CSP-style coroutine concurrency (aka **\"cooperative multitasking\"**).\n\nGenerators/iterable-sequences will receive a *control token* with a messages channel (`.messages` property is a simple array) to use for passing messages back and forth as the coroutines interleave.\n\nIf you `yield` (or `return` in the case of iterable-sequences) that *control token* back (or a sequence/promise that eventually produces it), then you will signal to transfer control to the next (round-robbin ordering style) generator/sequence in the concurrency-grouping.\n\nOtherwise, yielding/returning of any other type of value, **including a sequence/promise**, will retain control with the current generator/iterator-step.\n\nYou can also call `.add(..)` on the *control token* to add one or more generators/iterable-sequences to the concurrency-grouping:\n\n```js\n// promise to double `v` in 1000 ms\nfunction double(v) {\n\treturn new Promise(function(resolve,reject){\n\t\tsetTimeout(function(){\n\t\t\tresolve(v * 2);\n\t\t},1000);\n\t});\n}\n\nfunction makeGen(x,y) {\n\treturn function*(token){\n\t\ttoken.messages.push( yield double(x) );\n\t\tyield token;\n\t\ttoken.messages.push( yield double(y) );\n\t};\n}\n\nASQ()\n.runner(\n\tfunction*(token) {\n\t\ttoken.add(\n\t\t\tmakeGen(10,20),\n\t\t\tmakeGen(100,200)\n\t\t);\n\t\twhile (token.messages.length < 4) {\n\t\t\tyield token;\n\t\t}\n\t\tyield token.messages;\n\t}\n)\n.val(function(msg){\n\tconsole.log(msg); // [ 20, 200, 40, 400 ]\n});\n```\n\nWith both generators and iterable-sequences, the last *final* non-`undefined` value that is yielded/returned from the concurrency-grouping run will be the forward-passed message(s) to the next step in your main *asynquence* chain.\n\nIf you want to pass on the channel messages from your generator run, end your last generator by `yield`ing out the `.messages` property of the *control token* (see above snippet). Likewise with iterable-sequences, `return` the channel messages from the last iterable-sequence step.\n\nTo get a better sense of how this advanced functionality works, check out these examples:\n\n* [State Machine](http://jsbin.com/luron/1/edit?js,console) with simple generator co-routines (hidden CSP)\n* [Ping Pong](http://jsbin.com/qutabu/1/edit?js,output) (from [js-csp](https://github.com/ubolonton/js-csp/blob/master/README.md#examples) and the [go ping-pong](http://talks.golang.org/2013/advconc.slide#6) example)\n* [Two generators paired as CSP-style co-routines](https://gist.github.com/getify/10172207)\n\n#### go-Style CSP API Emulation\n\nIf you've heard of go-style CSP concurrency, such as in [Clojure's core.async](https://clojure.github.io/core.async/), or in various JS ports such as [@jlongster](http://github.com/jlongster)'s [js-csp fork](https://github.com/jlongster/js-csp) (also, [read his blog post](http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript)) of [ubolonton's js-csp](https://github.com/ubolonton/js-csp), *asynquence* has a (nearly-identical) API emulation layer that you can drop on top of *asynquence*'s CSP-flavored `runner(..)` mechanism described above to express channel-based concurrency.\n\nFor example:\n\n```js\nASQ()\n.runner(\n\tASQ.csp.go(function*(ch){\n\t\tyield ASQ.csp.put(ch,42);\n\t}),\n\tASQ.csp.go(function*(ch){\n\t\tyield ASQ.csp.take( ASQ.csp.timeout(1000) );\n\t\tconsole.log( yield ASQ.csp.take(ch) ); // 42\n\t})\n)\n.val(function(){\n\tconsole.log(\"all done\");\n});\n```\n\nTo use the go-style API emulation layer, you'll need (at least) the `iterable()` and `pThen()`/`pCatch()` contrib plugins.\n\nIn the browser:\n```html\n<script src=\"asq.js\"></script>\n<script src=\"contrib.js\"></script>\n<script src=\"asq-go-csp.js\"></script>\n```\n\nIn node:\n```js\nvar ASQ = require(\"asynquence\");\n\nrequire(\"asynquence-contrib\");\nrequire(\"asynquence-contrib/asq-go-csp.js\");\n```\n\ngo-style CSP can be a very powerful abstraction for certain concurrency tasks, so using this API emulation layer gives you even more choices for expressing and managing async flow control in your JS programs.\n\n### `react` Plugin\n\nConsider this kind of ugly code:\n\n```js\n$(\"#button\").click(function(evt){\n   ASQ(this.id)\n   .then(..)\n   .seq(..)\n   .then(..)\n   .val(..)\n});\n```\n\nEach time the button is clicked, a new sequence is defined and executed to \"react\" to the event. But it's a little awkward and ugly that the sequence must be (re)defined each time, *inside* the event listener.\n\nThe `react` plugin separates the capabilities of listening for events and of responding to them, providing first-class syntactic support for the *asynquence* \"reactive sequence\" pattern, inspired by [RxJS Reactive Observables](http://rxjs.codeplex.com/). It essentially combines *asynquence*'s flow-control with repeatable event handling.\n\n1. `react(..)` accepts a listener setup handler, which will receive a reactive trigger (called `proceed` in the snippet below) that event listener(s) \"react\" with by invoking. It will also receive a function you can call one or more times to register a *teardown* handler (to unbind event handlers, etc).\n\n2. The rest of the chain sets up a normal *asynquence* sequence, which will then be repeat-executed each time the reactive trigger is fired. The reactive sequence also has an added `stop()` method, which you can use to trigger any registered teardown handlers and stop all reactive sequence handling.\n\nThe `react` plugin reverses the paradigm of the first snippet, providing a way to specify the sequence externally and once, and have it be re-triggered each time an event fires.\n\n```js\nvar rsq = ASQ.react(\n   // this listener setup handler will be called only once\n   function setup(proceed,registerTeardownHandler){\n      // fire off a new sequence for each click\n      function handler(evt) {\n         // we can call `proceed(..)` (or whatever you want\n         // to call the param!) every time our stream/event\n         // fires, instead of just once like normal promise\n         // resolution\n         proceed(this.id);\n      }\n\n      $(\"#button\").click(handler);\n\n      // register a handler to be called when tearing down\n      // the reactive sequence handling\n      registerTeardownHandler(function(){\n         $(\"#button\").unbind(\"click\",handler);\n      });\n\n      // inside our `setup` handler, `this` will point to\n      // the reactive sequence, which has a `stop()` method\n      // that tears down the reactive sequence handling\n      EVTHUB.on(\"finish\",this.stop);\n   }\n)\n// each time our reactive event fires,\n// process the rest of this sequence\n.then(..)\n.seq(..)\n.then(..)\n.val(..);\n\n// later, to stop the reactive sequence handling:\nEVTHUB.on(\"totally-done\",rsq.stop);\n```\n\nInside the `react(..)` listener setup function, you can set up as many listeners for any kind of events (ajax, timers, click handlers, etc) as you want, and for each, all you need to do to fire off the sequence is call the `proceed(..)` (or whatever you want to name it!) callback. Whatever messages you pass to `proceed(..)` will pass along to the first step of the sequence instance.\n\nThe `proceed` function has two helpers on it for dealing with streams (particularly node streams): `proceed.onStream(..)` and `proceed.unStream(..)`. `onStream(..)` takes one or more streams and subscribes the `data` and `error` events to call the `proceed` function. `unStream(..)` takes one or more streams to unsubscribe, so you would likely use it in a registered teardown handler. For example:\n\n```js\nvar rsq = ASQ.react(function(proceed,registerTeardownHandler){\n\tproceed.onStream( mydatastream );\n\n\tregisterTeardownHandler(function(){\n\t\tproceed.unStream( mydatastream );\n\t});\n})\n.val(function(v){\n\tif (v instanceof Error) throw v;\n\t// ..\n})\n// ..\n.or(function(err){\n\tconsole.log(err);\n});\n```\n\nFor a more real-world type of example, see [reactive sequences + `gate()`](http://jsbin.com/rozipaki/6/edit?js,output). Here's [another example](https://gist.github.com/getify/bba5ec0de9d6047b720e), which handles http request/response streams with reactive sequences.\n\n## Using Contrib Plugins\n\nIn the browser, include the `contrib.js` file along with the *asynquence* library file (`asq.js`). Doing so automatically extends the API with the plugins.\n\nIn node.js, you install the `asynquence-contrib` package alongside the `asynquence` package. **Note:** The *asynquence-contrib* package will return the *asynquence* instance for you, so you technically only need this if using both:\n\n```js\n// Note: requiring \"asynquence\" not strictly needed here,\n// since contrib will retrieve and return it automatically\n\nvar ASQ = require(\"asynquence-contrib\");\n```\n\nThey can then be used together directly, like this:\n\n```js\nASQ()\n.try(foo)\n.until(bar)\n.then(baz);\n```\n\n**Note:** If you load contrib bundle(s) that cannot find a peer *asynquence* top-level package to load and use, a dependency-injection function is instead returned, which expects to be called with either an *asynquence* instance, or a relative path specifying where to load it.\n\n## Building Contrib Bundle\n\nThere is a utility provided to bundle the contrib plugins.\n\n```\nbundle.js usage:\n  bundle.js [ {OPTION} .. ] [ {PLUGIN-NAME} .. ]\n\n--help                    prints this help\n--wrapper=filename        wrapper filename (\"contrib-wrapper.js\")\n--bundle=filename         bundle filename (\"contrib.src.js\")\n--min-bundle=filename     minified-bundle filename (\"contrib.js\")\n--exclude={PLUGIN-NAME}   exclude a plugin from bundling\n\nIf you don't pass any {PLUGIN-NAME} parameters, all available plugins\n(except any that are --exclude omitted) will be bundled.\n\nIf you pass one or more {PLUGIN-NAME} parameters, only the ones\nspecified (except any that are --exclude omitted) will be bundled.\n```\n\n`bundle.js` by default builds the unminified bundle `contrib.src.js`, and then builds (minifies) `contrib.js`. The recommended way to invoke this utility is via npm:\n\n`npm run-script bundle`\n\nBy default, the build includes all the `contrib/plugin.*.js` plugins. But, you can manually specify which plugins you want, by name. For example, to bundle only the `any`, `none`, and `try` plugins:\n\n```\n./bundle.js any none try\n```\n\n**Note:** `npm run-script ..` [doesn't *currently*](https://github.com/isaacs/npm/issues/3494) support passing any extra command line parameters, so you must use `./bundle.js` **instead of** `npm run-script bundle` if you want to specify parameters to the bundle script.\n\nBy passing *option* parameters to the bundle script, you can override the default filenames used for the contrib plugin wrapper (`--wrapper=..`), bundle (`--bundle=..`), and minified-bundle (`--min-bundle=..`). These options are useful for creating multiple variations of the plugin bundle.\n\n## License\n\nThe code and all the documentation, unless otherwise noted, are released under the MIT license.\n\nhttp://getify.mit-license.org/\n",
  "readmeFilename": "README.md",
  "_id": "asynquence-contrib@0.9.0-a",
  "_shasum": "59ab09ccc061ae90836a1a702faeca30c2a5a20d",
  "_from": "asynquence-contrib@0.9.0-a"
}
